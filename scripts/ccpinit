#!/usr/bin/python

import os
import platform
from enum import Enum

project_root = input("Project Path: ")
project_name = input("Project Name: ")
cpp_standard = input("CXX Standard [def: 20]: ")
cxx_compiler = input("CXX Compiler [def: clang++]: ")
c_compiler = input("C Compiler [def: same as CXX]: ")
cmake_min_ver = input("CMake minimum version [def: 3.20]: ")
generator = input("Generator [def: Unix Makefiles]: ")
create_bin_dir = input("Create bin folder? [def: n] (y/n): ")
create_sub_projects = input("Create sub projects? [def: n] (y/n): ")
platform_arch = f'{platform.system()}-{platform.machine()}'.lower()
project_root = os.path.join(project_root, project_name)

# Expand tilde if present
if project_root[0] == '~':
    project_root = os.path.expanduser(project_root)

# Default settings
if not cpp_standard:
    cpp_standard = '20'
if not cxx_compiler:
    cxx_compiler = "clang++"
if not create_bin_dir:
    create_bin_dir = 'n'
if not create_sub_projects:
    create_sub_projects = 'n'
if not generator:
    generator = "Unix Makefiles"
if not cmake_min_ver:
    cmake_min_ver = "3.20"

# Detect compiler
if not c_compiler:
    if cxx_compiler.startswith("clang"):
        c_compiler = "clang"
    elif cxx_compiler.startswith("g++"):
        c_compiler = "gcc"

class FileType(Enum):
    GENERIC     = 0
    EXEC        = 1
    READONLY    = 2


class ProjectFile:
    def __init__(self, path, content, ftype):
        self.path = path
        self.content = content
        self.ftype = ftype

filer = [
    # Projectile file
    ProjectFile(".projectile", "", FileType.GENERIC),

    # Clang format file
    ProjectFile(".clang-format", '''BasedOnStyle: Microsoft
AlignTrailingComments: true
BreakBeforeBraces: Allman
ColumnLimit: 0
IndentWidth: 4
KeepEmptyLinesAtTheStartOfBlocks: false
PointerBindsToType: true
SpacesBeforeTrailingComments: 1
TabWidth: 4
UseTab: Never
IndentCaseLabels: true
NamespaceIndentation: All''', FileType.GENERIC),

    # Root CMakeLists.txt file
    ProjectFile("CMakeLists.txt", f'''# Auto-generated by ccpinit

cmake_minimum_required(VERSION {cmake_min_ver})
project("{project_name}")

set(CMAKE_CXX_STANDARD {cpp_standard})
set(CMAKE_EXPORT_COMPILE_COMMANDS 1)

if (DEFINED CMAKE_BUILD_TYPE)
    if (CMAKE_BUILD_TYPE STREQUAL "Debug")
        if (CMAKE_CXX_COMPILER_ID STREQUAL "Clang" OR CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
            set(CMAKE_CXX_FLAGS "${{CMAKE_CXX_FLAGS}} -O0")
        endif()
    elseif (CMAKE_BUILD_TYPE STREQUAL "Release")
        if (CMAKE_CXX_COMPILER_ID STREQUAL "Clang" OR CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
            set(CMAKE_CXX_FLAGS "${{CMAKE_CXX_FLAGS}} -O3")
        endif()
    endif()
else()
    if (CMAKE_CXX_COMPILER_ID STREQUAL "Clang" OR CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
        set(CMAKE_CXX_FLAGS "${{CMAKE_CXX_FLAGS}} -O0")
    endif()
endif()

add_subdirectory("{project_name}")''', FileType.GENERIC),

    # README.md file
    ProjectFile("README.md", f"# {project_name.upper()}", FileType.GENERIC),

    # build script file
    ProjectFile("build", f'''#!/bin/bash
# Auto-generated by ccpinit

clear
echo "Build started"

export CC=$(which {c_compiler})
export CXX=$(which {cxx_compiler})

platform="{platform_arch}"
build_conf="Debug"
cpwd=$pwd

if [ -z "$1" ]; then
    build_conf="Debug"
else
    build_conf="$1"
fi

if [ ! -d "builds" ]; then
    echo "Configuring CMake..."
        mkdir -p "builds"
        mkdir -p "builds/$platform"
        cd "builds/$platform"
        cmake -G "{generator}" -DCMAKE_BUILD_TYPE="$build_conf" ../../
elif [ ! -d "builds/$platform" ]; then
        echo "Configuring CMake.."
        mkdir -p "builds/$platform"
        cd "builds/$platform"
        cmake -G "{generator}" -DCMAKE_BUILD_TYPE="$build_conf" ../../
else
        cd "builds/$platform"
fi

echo "Building..."
cmake --build ./
cp "compile_commands.json" ../../

#if [ ! -d "../../bin" ]; then
#    mkdir -p "../../bin"
#fi
#cp "ALVM/ALVM" ../../bin/alvm
#cp "ALASM/ALASM" ../../bin/alasm

echo "Build finished."''', FileType.EXEC),

    # Base sub-project CMakeLists.txt file
    ProjectFile(f"{project_name}/CMakeLists.txt", f'''# Auto-generated by ccpinit 

# Fetch all the source and header files and the then add them automatically
file(GLOB_RECURSE {project_name.upper()}_SOURCES "src/*.cpp")
file(GLOB_RECURSE {project_name.upper()}_HEADERS "src/*.h")

add_executable({project_name.lower()} ${{{project_name.upper()}_SOURCES}} ${{{project_name.upper()}_HEADERS}})''', FileType.GENERIC),

    # main.cpp file
    ProjectFile(f"{project_name}/src/main.cpp", f'''#include <iostream>

int main(const int argc, const char* argv[])
{{
    std::cout << "cool" << std::endl;
    return 0;
}}''', FileType.GENERIC),
]

print("")

# Create the files
for file_info in filer:
    file_path = os.path.join(project_root, file_info.path)
    os.makedirs(os.path.dirname(file_path), exist_ok=True)
    print(f"[!]: Creating {file_path}...")
    with open(file_path, "w") as fs:
        fs.write(file_info.content)
    if platform.system().lower() == "linux" or platform.system().lower() == "darwin":
        if file_info.ftype == FileType.EXEC:
            os.chmod(file_path, 0o775)
            print("   - Running chmod 775")
        elif file_info.ftype == FileType.GENERIC:
            os.chmod(file_path, 0o664)
        elif file_info.ftype == FileType.READONLY:
            os.chmod(file_path, 0o644)
            print("   - Running chmod 644 (readonly for all except the owner)")

print("\n[!]: Project created.")
print("[!]: To build and compile, run the 'build' shell script at the root directory.")
